<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on The Odd Bit</title>
    <link>/tags/python/</link>
    <description>Recent content in python on The Odd Bit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/python/rss.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Writing Ansible filter plugins</title>
      <link>/post/2019-04-25-writing-ansible-filter-plugins/</link>
      <pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-04-25-writing-ansible-filter-plugins/</guid>
      <description>I often see questions from people who are attemping to perform complex text transformations in their Ansible playbooks. While I am a huge fan of Ansible, data transformation is not one of its strong points. For example, this past week someone asked a question on Stack Overflow in which they were attempting to convert the output of the keytool command into a list of dictionaries. The output of the keytool -list -v command looks something like this:</description>
    </item>
    
    <item>
      <title>Using a TM1637 LED module with CircuitPython</title>
      <link>/post/2018-05-03-using-a-tm-led-module-with-cir/</link>
      <pubDate>Thu, 03 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-05-03-using-a-tm-led-module-with-cir/</guid>
      <description>CircuitPython is &amp;ldquo;an education friendly open source derivative of MicroPython&amp;rdquo;. MicroPython is a port of Python to microcontroller environments; it can run on boards with very few resources such as the ESP8266. I&amp;rsquo;ve recently started experimenting with CircuitPython on a Wemos D1 mini, which is a small form-factor ESP8266 board.
I had previously been using Mike Causer&amp;rsquo;s micropython-tm1637 for MicroPython to drive a 4 digit LED display. I was hoping to get the same code working under CircuitPython, but when I tried to build an image that included the tm1637 module I ran into:</description>
    </item>
    
    <item>
      <title>A Python interface to signalfd() using FFI</title>
      <link>/post/2013-11-28-a-python-interface-to-signalfd/</link>
      <pubDate>Thu, 28 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/2013-11-28-a-python-interface-to-signalfd/</guid>
      <description>I just recently learned about the signalfd(2) system call, which was introduced to the Linux kernel back in 2007:
 signalfd() creates a file descriptor that can be used to accept signals targeted at the caller. This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7).
 The traditional asynchronous delivery mechanism can be tricky to get right, whereas this provides a convenient fd interface that integrates nicely with your existing event-based code.</description>
    </item>
    
    <item>
      <title>Long polling with Javascript and Python</title>
      <link>/post/2013-11-23-long-polling-with-ja/</link>
      <pubDate>Sat, 23 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/2013-11-23-long-polling-with-ja/</guid>
      <description>In this post I&amp;rsquo;m going to step through an example web chat system implemented in Python (with Bottle and gevent) that uses long polling to implement a simple publish/subscribe mechanism for efficiently updating connected clients.
My pubsub_example repository on GitHub has a complete project that implements the ideas discussed in this article. This project can be deployed directly on OpenShift if you want to try things out on your own.</description>
    </item>
    
    <item>
      <title>Interrupts on the PiFace</title>
      <link>/post/2013-08-05-interrupts-on-the-pi/</link>
      <pubDate>Mon, 05 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>/post/2013-08-05-interrupts-on-the-pi/</guid>
      <description>I recently acquired both a Raspberry Pi and a PiFace IO board. I had a rough time finding examples of how to read the input ports via interrupts (rather than periodically polling for values), especially for the newer versions of the PiFace python libraries.
After a little research, here&amp;rsquo;s some simple code that will print out pin names as you press the input buttons. Button 3 will cause the code to exit:</description>
    </item>
    
    <item>
      <title>Python ctypes module</title>
      <link>/post/2010-08-10-python-ctypes-module/</link>
      <pubDate>Tue, 10 Aug 2010 00:00:00 +0000</pubDate>
      
      <guid>/post/2010-08-10-python-ctypes-module/</guid>
      <description>I just learned about the Python ctypes module, which is a Python module for interfacing with C code. Among other things, ctypes lets you call arbitrary functions in shared libraries. This is, from my perspective, some very cool magic. I thought I would provide a short example here, since it took me a little time to get everything working smoothly.
For this example, we&amp;rsquo;ll write a wrapper for the standard statvfs(2) function:</description>
    </item>
    
    <item>
      <title>Retrieving Blogger posts by post id</title>
      <link>/post/2010-01-29-retrieving-blogger-posts-by-post-id/</link>
      <pubDate>Fri, 29 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>/post/2010-01-29-retrieving-blogger-posts-by-post-id/</guid>
      <description>I spent some time recently trying to figure out, using Google&amp;rsquo;s gdata API, how to retrieve a post from a Blogger blog if I know corresponding post id. As far as I can tell there is no obvious way of doing this, at least not using the gdata.blogger.client api, but after much nashing of teeth I came up with the following solution.
Given client, a gdata.blogger.client instance, and blog, a gdata.</description>
    </item>
    
  </channel>
</rss>