<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Odd Bit</title>

  
  <link rel="self" href="https://blog.oddbit.com/tag/python/atom.xml"/>
  
  <link href="https://blog.oddbit.com/tag/python/" rel="alternate"></link>

  <updated>2021-02-08T00:00:00Z</updated>
  <id>https://blog.oddbit.com/tag/python/</id>
  <entry>
    <title>Remediating poor PyPi performance with DevPi</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2021-02-08-remediating-poor-pypi-performa/"/>
    <id>https://blog.oddbit.com/post/2021-02-08-remediating-poor-pypi-performa/</id>
    <published>2021-02-08T00:00:00Z</published>
    <updated>2021-02-08T00:00:00Z</updated>
    <summary type="html">Performance of the primary PyPi service has been so bad lately that it&amp;rsquo;s become very disruptive. Tasks that used to take a few seconds will now churn along for 15-20 minutes or longer before completing, which is incredibly frustrating.
I first went looking to see if there was a PyPi mirror infrastructure, like we see with CPAN for Perl or CTAN for Tex (and similarly for most Linux distributions). There is apparently no such beast,</summary>
  </entry>
  
  <entry>
    <title>symtool: a tool for interacting with your SYM-1</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2021-02-06-symtool-a-tool-for-interacting/"/>
    <id>https://blog.oddbit.com/post/2021-02-06-symtool-a-tool-for-interacting/</id>
    <published>2021-02-06T00:00:00Z</published>
    <updated>2021-02-06T00:00:00Z</updated>
    <summary type="html">The SYM-1 is a 6502-based single-board computer produced by Synertek Systems Corp in the mid 1970&amp;rsquo;s. I&amp;rsquo;ve had one floating around in a box for many, many years, and after a recent foray into the world of 6502 assembly language programming I decided to pull it out, dust it off, and see if it still works.
The board I have has a whopping 8KB of memory, and in addition to the standard SUPERMON monitor it has the expansion ROMs for the Synertek BASIC interpreter (yet another Microsoft BASIC) and RAE (the &amp;ldquo;Resident Assembler Editor&amp;rdquo;).</summary>
  </entry>
  
  <entry>
    <title>To sleep or not to sleep?</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2020-12-18-to-sleep-or-not-to-sleep/"/>
    <id>https://blog.oddbit.com/post/2020-12-18-to-sleep-or-not-to-sleep/</id>
    <published>2020-12-18T00:00:00Z</published>
    <updated>2020-12-18T00:00:00Z</updated>
    <summary type="html">Let&amp;rsquo;s say you have a couple of sensors attached to an ESP8266 running MicroPython. You&amp;rsquo;d like to sample them at different frequencies (say, one every 60 seconds and one every five minutes), and you&amp;rsquo;d like to do it as efficiently as possible in terms of power consumption. What are your options?
If we don&amp;rsquo;t care about power efficiency, the simplest solution is probably a loop like this:
import machine lastrun_1 = 0 lastrun_2 = 0 while True: now = time.</summary>
  </entry>
  
  <entry>
    <title>I see you have the machine that goes ping...</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2020-03-20-i-see-you-have-the-machine-tha/"/>
    <id>https://blog.oddbit.com/post/2020-03-20-i-see-you-have-the-machine-tha/</id>
    <published>2020-03-20T00:00:00Z</published>
    <updated>2020-03-20T00:00:00Z</updated>
    <summary type="html">We&amp;rsquo;re all looking for ways to keep ourselves occupied these days, and for me that means leaping at the chance to turn a small problem into a slightly ridiculous electronics project. For reasons that I won&amp;rsquo;t go into here I wanted to generate an alert when a certain WiFi BSSID becomes visible. A simple solution to this problem would have been a few lines of shell script to send me an email&amp;hellip;but this article isn&amp;rsquo;t about simple solutions!</summary>
  </entry>
  
  <entry>
    <title>How long is a cold spell in Boston?</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2020-01-23-how-long-is-a-cold-spell/"/>
    <id>https://blog.oddbit.com/post/2020-01-23-how-long-is-a-cold-spell/</id>
    <published>2020-01-23T00:00:00Z</published>
    <updated>2020-01-23T00:00:00Z</updated>
    <summary type="html">We&amp;rsquo;ve had some wacky weather recently. In the space of a week, the temperature went from a high of about 75°F to a low around 15°F. This got me to thinking about what constitutes &amp;ldquo;normal&amp;rdquo; weather here in the Boston area, and in particular, how common it is to have a string of consecutive days in which the high temperature stays below freezing. While this was an interesting question in itself, it also seemed like a great opportunity to learn a little about Pandas, the Python data analysis framework.</summary>
  </entry>
  
  <entry>
    <title>Unpacking a Python regular expression</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2019-05-07-unpacking-a-python-regular-exp/"/>
    <id>https://blog.oddbit.com/post/2019-05-07-unpacking-a-python-regular-exp/</id>
    <published>2019-05-07T10:00:00Z</published>
    <updated>2019-05-07T10:00:00Z</updated>
    <summary type="html">I recently answered a question from Harsha Nalore on StackOverflow that involved using Ansible to extract the output of a command sent to a BigIP device of some sort. My solution &amp;ndash; which I claim to be functional, but probably not optimal &amp;ndash; involved writing an Ansible filter module to parse the output. That filter made use of a complex-looking regular expression. Harsha asked for some details on that regular expression works, and the existing StackOverflow answer didn&amp;rsquo;t really seem the write place for that: so, here we are.</summary>
  </entry>
  
  <entry>
    <title>Writing Ansible filter plugins</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2019-04-25-writing-ansible-filter-plugins/"/>
    <id>https://blog.oddbit.com/post/2019-04-25-writing-ansible-filter-plugins/</id>
    <published>2019-04-25T00:00:00Z</published>
    <updated>2019-04-25T00:00:00Z</updated>
    <summary type="html">I often see questions from people who are attemping to perform complex text transformations in their Ansible playbooks. While I am a huge fan of Ansible, data transformation is not one of its strong points. For example, this past week someone asked a question on Stack Overflow in which they were attempting to convert the output of the keytool command into a list of dictionaries. The output of the keytool -list -v command looks something like this:</summary>
  </entry>
  
  <entry>
    <title>Using a TM1637 LED module with CircuitPython</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2018-05-03-using-a-tm-led-module-with-cir/"/>
    <id>https://blog.oddbit.com/post/2018-05-03-using-a-tm-led-module-with-cir/</id>
    <published>2018-05-03T00:00:00Z</published>
    <updated>2018-05-03T00:00:00Z</updated>
    <summary type="html">CircuitPython is &amp;ldquo;an education friendly open source derivative of MicroPython&amp;rdquo;. MicroPython is a port of Python to microcontroller environments; it can run on boards with very few resources such as the ESP8266. I&amp;rsquo;ve recently started experimenting with CircuitPython on a Wemos D1 mini, which is a small form-factor ESP8266 board.
I had previously been using Mike Causer&amp;rsquo;s micropython-tm1637 for MicroPython to drive a 4 digit LED display. I was hoping to get the same code working under CircuitPython, but when I tried to build an image that included the tm1637 module I ran into:</summary>
  </entry>
  
  <entry>
    <title>A Python interface to signalfd() using FFI</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2013-11-28-a-python-interface-to-signalfd/"/>
    <id>https://blog.oddbit.com/post/2013-11-28-a-python-interface-to-signalfd/</id>
    <published>2013-11-28T00:00:00Z</published>
    <updated>2013-11-28T00:00:00Z</updated>
    <summary type="html">I just recently learned about the signalfd(2) system call, which was introduced to the Linux kernel back in 2007:
 signalfd() creates a file descriptor that can be used to accept signals targeted at the caller. This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7).
 The traditional asynchronous delivery mechanism can be tricky to get right, whereas this provides a convenient fd interface that integrates nicely with your existing event-based code.</summary>
  </entry>
  
  <entry>
    <title>Long polling with Javascript and Python</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2013-11-23-long-polling-with-ja/"/>
    <id>https://blog.oddbit.com/post/2013-11-23-long-polling-with-ja/</id>
    <published>2013-11-23T00:00:00Z</published>
    <updated>2013-11-23T00:00:00Z</updated>
    <summary type="html">In this post I&amp;rsquo;m going to step through an example web chat system implemented in Python (with Bottle and gevent) that uses long polling to implement a simple publish/subscribe mechanism for efficiently updating connected clients.
My pubsub_example repository on GitHub has a complete project that implements the ideas discussed in this article. This project can be deployed directly on OpenShift if you want to try things out on your own. You can also try it out online at http://pubsub.</summary>
  </entry>
  
  <entry>
    <title>Interrupts on the PiFace</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2013-08-05-interrupts-on-the-pi/"/>
    <id>https://blog.oddbit.com/post/2013-08-05-interrupts-on-the-pi/</id>
    <published>2013-08-05T00:00:00Z</published>
    <updated>2013-08-05T00:00:00Z</updated>
    <summary type="html">I recently acquired both a Raspberry Pi and a PiFace IO board. I had a rough time finding examples of how to read the input ports via interrupts (rather than periodically polling for values), especially for the newer versions of the PiFace python libraries.
After a little research, here&amp;rsquo;s some simple code that will print out pin names as you press the input buttons. Button 3 will cause the code to exit:</summary>
  </entry>
  
  <entry>
    <title>Python ctypes module</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2010-08-10-python-ctypes-module/"/>
    <id>https://blog.oddbit.com/post/2010-08-10-python-ctypes-module/</id>
    <published>2010-08-10T00:00:00Z</published>
    <updated>2010-08-10T00:00:00Z</updated>
    <summary type="html">I just learned about the Python ctypes module, which is a Python module for interfacing with C code. Among other things, ctypes lets you call arbitrary functions in shared libraries. This is, from my perspective, some very cool magic. I thought I would provide a short example here, since it took me a little time to get everything working smoothly.
For this example, we&amp;rsquo;ll write a wrapper for the standard statvfs(2) function:</summary>
  </entry>
  
  <entry>
    <title>Retrieving Blogger posts by post id</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2010-01-29-retrieving-blogger-posts-by-post-id/"/>
    <id>https://blog.oddbit.com/post/2010-01-29-retrieving-blogger-posts-by-post-id/</id>
    <published>2010-01-29T00:00:00Z</published>
    <updated>2010-01-29T00:00:00Z</updated>
    <summary type="html">I spent some time recently trying to figure out, using Google&amp;rsquo;s gdata API, how to retrieve a post from a Blogger blog if I know corresponding post id. As far as I can tell there is no obvious way of doing this, at least not using the gdata.blogger.client api, but after much nashing of teeth I came up with the following solution.
Given client, a gdata.blogger.client instance, and blog, a gdata.</summary>
  </entry>
  
</feed>
