<feed xmlns="http://www.w3.org/2005/Atom">
  <title>python on The Odd Bit</title>

  
  <link rel="self" href="https://blog.oddbit.com/tag/python/atom.xml"/>
  
  <link href="https://blog.oddbit.com/tag/python/" rel="alternate"></link>

  <updated>2019-05-07T00:00:00Z</updated>
  <id>https://blog.oddbit.com/tag/python/</id>
  
  <entry>
    <title>Unpacking a Python regular expression</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2019-05-07-unpacking-a-python-regular-exp/"/>
    <id>https://blog.oddbit.com/post/2019-05-07-unpacking-a-python-regular-exp/</id>
    <published>2019-05-07T00:00:00Z</published>
    <updated>2019-05-07T00:00:00Z</updated>
    <summary type="html">I recently answered a question from Harsha Nalore on StackOverflow that involved using Ansible to extract the output of a command sent to a BigIP device of some sort. My solution &amp;ndash; which I claim to be functional, but probably not optimal &amp;ndash; involved writing an Ansible filter module to parse the output. That filter made use of a complex-looking regular expression. Harsha asked for some details on that regular expression works, and the existing StackOverflow answer didn&amp;rsquo;t really seem the write place for that: so, here we are.</summary>
  </entry>
  
  <entry>
    <title>Writing Ansible filter plugins</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2019-04-25-writing-ansible-filter-plugins/"/>
    <id>https://blog.oddbit.com/post/2019-04-25-writing-ansible-filter-plugins/</id>
    <published>2019-04-25T00:00:00Z</published>
    <updated>2019-04-25T00:00:00Z</updated>
    <summary type="html">I often see questions from people who are attemping to perform complex text transformations in their Ansible playbooks. While I am a huge fan of Ansible, data transformation is not one of its strong points. For example, this past week someone asked a question on Stack Overflow in which they were attempting to convert the output of the keytool command into a list of dictionaries. The output of the keytool -list -v command looks something like this:</summary>
  </entry>
  
  <entry>
    <title>Using a TM1637 LED module with CircuitPython</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2018-05-03-using-a-tm-led-module-with-cir/"/>
    <id>https://blog.oddbit.com/post/2018-05-03-using-a-tm-led-module-with-cir/</id>
    <published>2018-05-03T00:00:00Z</published>
    <updated>2018-05-03T00:00:00Z</updated>
    <summary type="html">CircuitPython is &amp;ldquo;an education friendly open source derivative of MicroPython&amp;rdquo;. MicroPython is a port of Python to microcontroller environments; it can run on boards with very few resources such as the ESP8266. I&amp;rsquo;ve recently started experimenting with CircuitPython on a Wemos D1 mini, which is a small form-factor ESP8266 board.
I had previously been using Mike Causer&amp;rsquo;s micropython-tm1637 for MicroPython to drive a 4 digit LED display. I was hoping to get the same code working under CircuitPython, but when I tried to build an image that included the tm1637 module I ran into:</summary>
  </entry>
  
  <entry>
    <title>A Python interface to signalfd() using FFI</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2013-11-28-a-python-interface-to-signalfd/"/>
    <id>https://blog.oddbit.com/post/2013-11-28-a-python-interface-to-signalfd/</id>
    <published>2013-11-28T00:00:00Z</published>
    <updated>2013-11-28T00:00:00Z</updated>
    <summary type="html">I just recently learned about the signalfd(2) system call, which was introduced to the Linux kernel back in 2007:
 signalfd() creates a file descriptor that can be used to accept signals targeted at the caller. This provides an alternative to the use of a signal handler or sigwaitinfo(2), and has the advantage that the file descriptor may be monitored by select(2), poll(2), and epoll(7).
 The traditional asynchronous delivery mechanism can be tricky to get right, whereas this provides a convenient fd interface that integrates nicely with your existing event-based code.</summary>
  </entry>
  
  <entry>
    <title>Long polling with Javascript and Python</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2013-11-23-long-polling-with-ja/"/>
    <id>https://blog.oddbit.com/post/2013-11-23-long-polling-with-ja/</id>
    <published>2013-11-23T00:00:00Z</published>
    <updated>2013-11-23T00:00:00Z</updated>
    <summary type="html">In this post I&amp;rsquo;m going to step through an example web chat system implemented in Python (with Bottle and gevent) that uses long polling to implement a simple publish/subscribe mechanism for efficiently updating connected clients.
My pubsub_example repository on GitHub has a complete project that implements the ideas discussed in this article. This project can be deployed directly on OpenShift if you want to try things out on your own.</summary>
  </entry>
  
  <entry>
    <title>Interrupts on the PiFace</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2013-08-05-interrupts-on-the-pi/"/>
    <id>https://blog.oddbit.com/post/2013-08-05-interrupts-on-the-pi/</id>
    <published>2013-08-05T00:00:00Z</published>
    <updated>2013-08-05T00:00:00Z</updated>
    <summary type="html">I recently acquired both a Raspberry Pi and a PiFace IO board. I had a rough time finding examples of how to read the input ports via interrupts (rather than periodically polling for values), especially for the newer versions of the PiFace python libraries.
After a little research, here&amp;rsquo;s some simple code that will print out pin names as you press the input buttons. Button 3 will cause the code to exit:</summary>
  </entry>
  
  <entry>
    <title>Python ctypes module</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2010-08-10-python-ctypes-module/"/>
    <id>https://blog.oddbit.com/post/2010-08-10-python-ctypes-module/</id>
    <published>2010-08-10T00:00:00Z</published>
    <updated>2010-08-10T00:00:00Z</updated>
    <summary type="html">I just learned about the Python ctypes module, which is a Python module for interfacing with C code. Among other things, ctypes lets you call arbitrary functions in shared libraries. This is, from my perspective, some very cool magic. I thought I would provide a short example here, since it took me a little time to get everything working smoothly.
For this example, we&amp;rsquo;ll write a wrapper for the standard statvfs(2) function:</summary>
  </entry>
  
  <entry>
    <title>Retrieving Blogger posts by post id</title>
    <author>
      <name>Lars Kellogg-Stedman</name>
    </author>
    <link rel="alternate" href="https://blog.oddbit.com/post/2010-01-29-retrieving-blogger-posts-by-post-id/"/>
    <id>https://blog.oddbit.com/post/2010-01-29-retrieving-blogger-posts-by-post-id/</id>
    <published>2010-01-29T00:00:00Z</published>
    <updated>2010-01-29T00:00:00Z</updated>
    <summary type="html">I spent some time recently trying to figure out, using Google&amp;rsquo;s gdata API, how to retrieve a post from a Blogger blog if I know corresponding post id. As far as I can tell there is no obvious way of doing this, at least not using the gdata.blogger.client api, but after much nashing of teeth I came up with the following solution.
Given client, a gdata.blogger.client instance, and blog, a gdata.</summary>
  </entry>
  
</feed>
